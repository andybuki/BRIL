package uk.ac.kcl.cerch.bril.ccp4.processor.log;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.util.Vector;

import uk.ac.kcl.cerch.bril.ccp4.TaskObject;

public class DEFPhenixProcessor {
	private File logFile;
	private Vector<String> inputs = null;
	private TaskObject taskObject = new TaskObject();
	String prefix=null;
	String autogeneratedFile=null;
	public DEFPhenixProcessor(File defFileLocation) {
		inputs = new Vector<String>();
		this.logFile = defFileLocation;	
	//can't use this as the file is uploaded to server and thus uploaded data is reeturned.
		//can use the date in the metdata file.
	  /*   String dateTime = new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm:ss")
	     .format(new Date(logFile.lastModified()));
	     taskObject.setRunDateTime(dateTime);*/
	     
		readLOGFile();
		
	}
	public TaskObject readLOGFile() {
		
		try {
			Scanner scanner = new Scanner(logFile);
			scanner.useDelimiter(System.getProperty("line.separator"));

			while (scanner.hasNext()) {
				parseLineHeader(scanner.next());
			}

			scanner.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
		//set the input to the task vector
		// set the input to the task vector
		if (inputs != null) {
			Vector<String> in = new Vector<String>(new LinkedHashSet<String>(inputs));
			System.out.println("inputs: (" + in.toString() + ")");
			for (int i = 0; i < in.size(); i++) {
				taskObject.setInputFileName(in.get(i).toString());
			}
		}
		
		//set the prefix used in all output files produced by this DEF file as jobid
		taskObject.setJobID(prefix);
		//set the task name
		if(autogeneratedFile==null){
			taskObject.setTaskName("phenix.refine");
			}else 
				if(autogeneratedFile!=null){
			taskObject.setTaskName("phenix.refine"+autogeneratedFile);
			}
		
		taskObject.setSoftwareName("phenix");
		return taskObject;
	}
	private void parseLineHeader(String line) {
		//System.out.println(line);
	
		String aLine;
		Scanner lineScanner = new Scanner(line);
		//lineScanner.useDelimiter("\\s*User:\\s*");
		lineScanner.useDelimiter("\n");
		while (lineScanner.hasNext()) {
			aLine = lineScanner.next();
					
			//System.out.println("-----------");
			
			boolean hastokenHash=hasToken(aLine, "#");
			//boolean hastokenRefinement=hasToken(aLine,"refinement");
			boolean hastokenFileName=hasToken(aLine,"file_name");
			boolean hastokenPrefix=hasToken(aLine,"prefix");
			boolean hasOtherPrefix=hasToken(aLine,"file_prefix");
			boolean colon= aLine.contains("\"");
			//System.out.println("char token: "+hastokenHtml);
			if(hastokenHash==true){
				if(aLine.contains("subsequent") && aLine.contains("refinement")){
					//This is auto-generate def file after a refine step by phenix
					autogeneratedFile=".subsequent";
					//System.out.println("subsequent refinement");
				}
			}
		
			if (hastokenHash == false && hastokenFileName==true){
			//	System.out.println("takenLine: "+aLine);
				if(aLine.indexOf('"')!=-1){
					String s = aLine.substring(aLine.indexOf('"')+1,aLine.lastIndexOf('"'));
					if(s!=null){
						//taskObject.setInputFileName(s);
						inputs.add(s);	
						//System.out.println(s);
					}
				
				}
			}
			if (hastokenHash == false && hastokenPrefix==true && hasOtherPrefix==false){
				
				if(aLine.indexOf('"')!=-1){
					String s = aLine.substring(aLine.indexOf('"')+1,aLine.lastIndexOf('"'));
					if(s!=null){
						//System.out.println("prefix: "+s);
						prefix=s;
					}
				
				}
	
			}
			
		}	
		if(prefix==null){
			String filename =logFile.getName();
			if(!filename.contains("_")){
			 prefix =filename.substring(0,filename.lastIndexOf("."));	
			//System.out.println("prefix1: "+ prefix);
			}
			if(filename.contains("_")){
				 prefix =filename.substring(0,filename.lastIndexOf("_"));
			//	System.out.println("prefix1: "+ prefix);
			}
			
		}
		
		
		
	
		
	}
	public Vector<String> getInputs(){
		Vector<String> newInputs = removeDuplicates(inputs);
		return newInputs;
		
	}
	
	public static Vector<String> removeDuplicates(Vector<String> s) {
		    int i = 0;
		    int j = 0;
		    boolean duplicates = false;

		    Vector<String> v = new Vector<String>();

		    for (i = 0; i < s.size(); i++) {
		      duplicates = false;
		      for (j = (i + 1); j < s.size(); j++) {
		        if (s.elementAt(i).toString().equalsIgnoreCase(
		            s.elementAt(j).toString())) {
		          duplicates = true;
		        }

		      }
		      if (duplicates == false) {
		        v.addElement(s.elementAt(i).toString().trim());
		      }

		    }

		    return v;
		  }
	 
	 public TaskObject getTaskObject(){
		
		 return taskObject;
	 }

	private boolean hasToken(String line, String token){
		boolean lineHasToken=false;
		 StringTokenizer st = new StringTokenizer(line);
		     while (st.hasMoreTokens()) {
		    	 //System.out.println();
		    	 String tok = st.nextToken();
		    	if(tok.equals(token)){
		    		lineHasToken=true;
		    	//	System.out.println("title line:" +line); 
		    	  }
		     }
		return lineHasToken;
	}
	
	public static void main(String arg[]){
		File file = new File("C:\\brilstore\\00EXPT123\\1\\1ref.def");
		DEFPhenixProcessor d = new DEFPhenixProcessor(file);
		System.out.println(d.getInputs());
	
		Vector<String> newInputs = d.getTaskObject().getInputFileNames();
		System.out.println(newInputs);
		
	}
	
}
