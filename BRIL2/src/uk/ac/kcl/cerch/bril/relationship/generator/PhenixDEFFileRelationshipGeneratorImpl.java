package uk.ac.kcl.cerch.bril.relationship.generator;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Vector;

import javax.xml.namespace.QName;
import javax.xml.parsers.ParserConfigurationException;

import uk.ac.kcl.cerch.bril.ccp4.TaskObject;
import uk.ac.kcl.cerch.bril.ccp4.processor.log.DEFPhenixProcessor;
import uk.ac.kcl.cerch.bril.common.fedora.BrilObjectRepositoryException;
import uk.ac.kcl.cerch.bril.common.fedora.FedoraAdminstrationImpl;
import uk.ac.kcl.cerch.bril.common.fedora.FedoraRelsExt;
import uk.ac.kcl.cerch.bril.common.fedora.FedoraNamespaceContext.FedoraNamespace;
import uk.ac.kcl.cerch.bril.common.metadata.DublinCore;
import uk.ac.kcl.cerch.bril.common.types.BrilRelationshipType;
import uk.ac.kcl.cerch.bril.common.types.BrilTransformException;
import uk.ac.kcl.cerch.bril.common.types.DataStreamType;
import uk.ac.kcl.cerch.bril.common.types.DatastreamMimeType;
import uk.ac.kcl.cerch.bril.common.types.DatastreamObjectContainer;
import uk.ac.kcl.cerch.bril.common.util.DateTime;
import uk.ac.kcl.cerch.bril.fileformat.CrystallographyObjectType;
import uk.ac.kcl.cerch.bril.relationship.ObjectRelationship;
import uk.ac.kcl.cerch.bril.relationship.common.GeneratorUtils;
import uk.ac.kcl.cerch.bril.service.uuid.IDGenerator;
import uk.ac.kcl.cerch.soapi.objectstore.ObjectStoreException;

public class PhenixDEFFileRelationshipGeneratorImpl implements PhenixDEFFileRelationshipGenerator{
	
	private ObjectRelationship objectRelationship;
	private GeneratorUtils generatorUtils;
	private String filepath;
	private TaskObject taskObject;
	@Override
	public ObjectRelationship generateRelationships(String objectId,
			String experimentId) {
		
		if (experimentId.contains("bril:") == false) {
			experimentId = "bril:" + experimentId;
		}
		
		objectRelationship = new ObjectRelationship();
		generatorUtils = new GeneratorUtils();
		
		objectRelationship.addRelationship(objectId, "isPartOf", experimentId);
		//objectRelationship.addRelationship(experimentId, "hasPart", objectID);			
				
		try {
			/**
			 * Search in the object store for this object's DC data that sets
			 * title and date values to the setter methods in the GeneratorUtils
			 */
			generatorUtils.searchForArchivalObjects(objectId);
		
		} catch (ObjectStoreException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}		
		
		mapToTaskObject(objectId);		
		Vector<String> in = new Vector<String>(new LinkedHashSet<String>(taskObject.getInputFileNames()));		
		Vector<String> inputObjectIdVector = getInputFileObjectIds(in, experimentId);		
				
		for (int o = 0; o < in.size(); o++) {
						
			boolean hasRel = false;	
			String foundPhenixProcess = null;
			if (in.get(o).contains(".pdb")) {
				 
				// search for all PHENIX processes, then check if current input has a 'wasGeneratedBy' relationship with found process
				Vector<String> phenixProcesses = generatorUtils.searchForObjectIds(experimentId, "title", "PHENIXProcess");				
				for (int i = 0; i < phenixProcesses.size(); i++) {
					// search for PDB inputs for each found phenix process
					String phenixProcess = phenixProcesses.get(i);
					hasRel = generatorUtils.hasRelationship(inputObjectIdVector.get(o), 
									BrilRelationshipType.wasGeneratedBy.getRelation(), phenixProcess);
					foundPhenixProcess = phenixProcess; 
				}
								
				if (hasRel) {					
					System.out.println(in.get(o) + " :in the input was generated by an existing phenix process: " + foundPhenixProcess);														
					objectRelationship.addRelationship(objectId, 
							BrilRelationshipType.wasGeneratedBy.getRelation(), foundPhenixProcess);
					System.out.println("relationship: " + objectId + " --wasGeneratedBy--> " + foundPhenixProcess);
					
				} else {														
					System.out.println(in.get(o) + " :in the input was not generated by an existing phenix process");
															
					// check if the pdb input has a 'used' relationship with a phenix process
					Vector<String> PHENIXProcesses = generatorUtils.
						getRelatedObjects(experimentId, "PHENIXProcess", BrilRelationshipType.used.getRelation(), inputObjectIdVector.get(o));
					
					if (PHENIXProcesses.size() == 0) {
						System.out.println(in.get(o) + " :in the input was not used in an existing phenix process");
					
						String objectDate = generatorUtils.getObjectDate();
						long dateDEF = uk.ac.kcl.cerch.bril.common.util.DateTime.getLongDateTime(
								objectDate, "dd/MM/yyyy HH:mm:ss");
						String pdbDate = generatorUtils.searchForObjectDate(experimentId, inputObjectIdVector.get(o));
						long datePDB = getLongDate(pdbDate);
						long dateDifference = dateDEF - datePDB;
						String diffvalue = String.valueOf(dateDifference);
						if (diffvalue.contains("-") == false) {
							System.out.println(in.get(o) + " is older than " + objectId);						
							String phenixProcessId = createPHENIXProcessInFedora(experimentId, objectId, inputObjectIdVector);
							System.out.println("Created 'PHENIX' process: " + phenixProcessId);						
						}						
					}										
				}
			}
		}				
		
		return objectRelationship;
	}	
	
	/**
	 * Creates a phenix process in the repository that consists of 
	 * 1) 'isPartOf' relationship to the experiment	 
	 * 2) 'used' relationship to the DEF file
	 * 3) 'wasControlledBy' relationship to the user (get this from the form?)
	 * 4) 'wasControlledBy' relationship to 'phenix'
	 *
	 * @param experimentId
	 * @param objectID
	 * @param inputObjectID 
	 * 
	 * @return the identifier of the newly created phenix process.
	 */	
	private String createPHENIXProcessInFedora(String experimentId, String phenixObjectId, Vector<String> inputObjectsIds) {

		String expId = experimentId;		
		//check if id has the prefix bril, if true true take only the bit after 'bril:'
		if (experimentId.lastIndexOf(':') != -1){
			expId = experimentId.substring(experimentId.lastIndexOf(':') + 1);
		}
		
		String phenixProcessID = "bril:process-" + IDGenerator.generateUUID();
		ByteArrayOutputStream relsExt_baos = new ByteArrayOutputStream();
		
		DublinCore digitalObjectDC = new DublinCore(phenixProcessID);
		digitalObjectDC.setTitle("PHENIXProcess");
		digitalObjectDC.setDescription("Structural Refinement using PHENIX");
		//digitalObjectDC.setDate("", "dd/MM/yyyy HH:mm:ss");
		System.out.println("-------- END: Create Dublin code metadata created --------------");
		
		DatastreamObjectContainer dsc = new DatastreamObjectContainer(phenixProcessID);
		dsc.addMetaData(digitalObjectDC);
		dsc.addDatastreamObject(DataStreamType.OriginalData,
			DatastreamMimeType.TEXT_XML.getMimeType(), "PHENIXProcess", "bril", null);
		
		/*
		 * create relationships*/
		FedoraRelsExt relsExt = null;
		try {
			relsExt = new FedoraRelsExt(FedoraNamespace.FEDORA.getURI() + phenixProcessID);
			
			// Process ---isPartOf---> Experiment
			QName predicate = new QName(FedoraNamespace.FEDORARELSEXT.getURI(), "isPartOf", FedoraNamespace.FEDORA.getPrefix());
			QName object = new QName("", expId, FedoraNamespace.FEDORA.getURI() + FedoraNamespace.BRIL.getPrefix());				
			relsExt.addRelationship(predicate, object);	
			System.out.println("relationship: " + phenixProcessID + " --isPartOf--> " + expId);
			
			// Process ---used---> DEF file
			predicate = new QName(FedoraNamespace.OPMV.getURI(), BrilRelationshipType.used.getRelation(), 
					FedoraNamespace.OPMV.getPrefix());
			if (phenixObjectId.contains("/")) {
				phenixObjectId = phenixObjectId.substring(phenixObjectId.lastIndexOf("/") + 1);
			}
			if (phenixObjectId.contains(":")){
				phenixObjectId = phenixObjectId.substring(phenixObjectId.lastIndexOf(":") + 1);
			}
			object = new QName("", phenixObjectId, FedoraNamespace.FEDORA.getURI() + FedoraNamespace.BRIL.getPrefix());				
			relsExt.addRelationship(predicate, object);
			System.out.println("relationship: " + phenixProcessID + " --used--> " + phenixObjectId);
						
			// Process ---used---> input files							
			for (int i = 0; i < inputObjectsIds.size(); i++) {
				String InputObjectId = inputObjectsIds.get(i).toString();
				if (InputObjectId.contains("/")) {
					InputObjectId = InputObjectId.substring(InputObjectId.lastIndexOf("/") + 1);
				}
				if (InputObjectId.contains(":")) {
					InputObjectId = InputObjectId.substring(InputObjectId.lastIndexOf(":") + 1);
				}
				predicate = new QName(FedoraNamespace.OPMV.getURI(), BrilRelationshipType.used.getRelation(), FedoraNamespace.OPMV.getPrefix());
				object = new QName("", InputObjectId, FedoraNamespace.FEDORA.getURI() + FedoraNamespace.BRIL.getPrefix());				
				relsExt.addRelationship(predicate, object);				
				System.out.println("relationship: " + phenixProcessID + " --used--> " + InputObjectId);
			}
			
			// Process ---wasControlledBy---> User
			// TODO: need to get user name from experiment creation form
			predicate = new QName(FedoraNamespace.OPMV.getURI(), BrilRelationshipType.wasControlledBy.getRelation(), FedoraNamespace.OPMV.getPrefix());
			object = new QName("", "Stella Fabiane", "");					
			relsExt.addRelationship(predicate, object);
			System.out.println("relationship: " + phenixProcessID + " --wasControlledBy--> Stella Fabiane");			
			
			// Process ---wasControlledBy---> PHENIX
			predicate = new QName(FedoraNamespace.OPMV.getURI(), BrilRelationshipType.wasControlledBy.getRelation(), FedoraNamespace.OPMV.getPrefix());
			object = new QName("", "PHENIX", "");					
			relsExt.addRelationship(predicate, object);
			System.out.println("relationship: " + phenixProcessID + " --wasControlledBy--> PHENIX");
			
			relsExt.serialize(relsExt_baos, "");
			
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (BrilTransformException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		byte[] relsExtByteArray = relsExt_baos.toByteArray();
		
		/*create datastream object container*/
		DatastreamObjectContainer dsc1 = new DatastreamObjectContainer(digitalObjectDC.getIdentifier());
		dsc1.addMetaData(digitalObjectDC);
		dsc1.addDatastreamObject(DataStreamType.OriginalData, DatastreamMimeType.TEXT_XML.getMimeType(), "PHENIXProcess", "bril", null);
		dsc1.addDatastreamObject(DataStreamType.RelsExt, DatastreamMimeType.APPLICATION_RDF.getMimeType(), "relationship", "bril", relsExtByteArray);
			 
		try {
			FedoraAdminstrationImpl fedoraAdmin = new FedoraAdminstrationImpl();
			fedoraAdmin.storeObject(dsc1);
		} catch (BrilObjectRepositoryException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return phenixProcessID;
	}
	
	private long getLongDate(String dateString) {
		// return format 2008-06-17T09:29:03
		if (dateString.contains(".")) {
			dateString = dateString.substring(0, dateString.lastIndexOf("."));
		}

		// return format 17/06/2008 09:22:46
		String stDate = DateTime.getDateTime(dateString, "yyyy-MM-dd'T'HH:mm:ss");
		long longDate = DateTime.getLongDateTime(stDate, "dd/MM/yyyy HH:mm:ss");
	
		return longDate;
	}
	
	public void mapToTaskObject(String objectId){
		/**
		 * Process the file of this object to get the taskobjectVector
		 */
		if (filepath == null) {			
			setFilePathFromArchivalObject(objectId);
		}
		File file = new File(filepath);			
		this.taskObject = getTaskObject(objectId, file);
	}
	
	private TaskObject getTaskObject(String objectID, File file ) {
		TaskObject taskObject = new TaskObject();
		DEFPhenixProcessor phenixProcessor = new DEFPhenixProcessor(file);
		taskObject =  phenixProcessor.readLOGFile();		
		return taskObject;
	}
	
	private void setFilePathFromArchivalObject(String objectID) {

		try {
			this.filepath = generatorUtils.getOriginalContentFilePath(objectID);
			System.out.println(filepath);
		} catch (ObjectStoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private Vector<String> getInputFileObjectIds(Vector<String> inputNameList,
			String experimentId) {
		System.out.println("========== Start Search for input files names in repository and get ids ===========");
		Vector<String> inputObjectIds = new Vector<String>();

		System.out.println("Input filenames: " + inputNameList);
		for (int o = 0; o < inputNameList.size(); o++) {
			String inputFilename = inputNameList.get(o);

			String suffix = inputFilename.substring(inputFilename
					.lastIndexOf(".") + 1);
			System.out.println(inputFilename);

			if (suffix.equals("pdb")) {
				System.out.println("===== PDB ====");
				Map<String, Vector<String>> pdbObjectIdTitle = generatorUtils
						.searchForObjectIdsTitle(experimentId, CrystallographyObjectType.CoordinateFile);

				// get the object's filename in title = filename
				for (Map.Entry<String, Vector<String>> ent : pdbObjectIdTitle.entrySet()) {

					String path = ent.getValue().get(0);
					String pdbFileName = null;
					String inputPDBName = null;
					char slash1 = '/';
					char slash2 = '\\';
					if (path.lastIndexOf(slash1) != -1) {
						pdbFileName = path.substring(path.lastIndexOf(slash1) + 1);		
						inputPDBName = inputFilename.substring(inputFilename.lastIndexOf(slash1) + 1);
					}

					if (path.lastIndexOf(slash2) != -1) {
						pdbFileName = path.substring(path.lastIndexOf(slash2) + 1);
						inputPDBName = inputFilename.substring(inputFilename.lastIndexOf(slash2) + 1);
					}

					System.out.println("inputPDBName: (" + inputPDBName + ")");
					System.out.println("pdbFileName: (" + pdbFileName + ")");
					if (inputPDBName.equals(pdbFileName)) {
						inputObjectIds.add(ent.getKey());
					}
				}
			} else if (suffix.equals("mtz")) {
				System.out.println("===== MTZ ====");
				Map<String, Vector<String>> mtzObjectIdTitle = generatorUtils
						.searchForObjectIdsTitle(experimentId, CrystallographyObjectType.MTZReflectionFile);
			
				// get the object's filename in title = filename
				for (Map.Entry<String, Vector<String>> ent : mtzObjectIdTitle.entrySet()) {
					String path = ent.getValue().get(0);
					String mtzFileName = null;
					String inputMTZName = null;
					char slash1 = '/';
					char slash2 = '\\';

					
					if (path.lastIndexOf(slash1) != -1) {
						mtzFileName = path.substring(path.lastIndexOf(slash1) + 1);		
						inputMTZName = inputFilename.substring(inputFilename.lastIndexOf(slash1) + 1);
					}
					
					if (path.lastIndexOf(slash2) != -1) {
						mtzFileName = path.substring(path.lastIndexOf(slash2) + 1);
						inputMTZName = inputFilename.substring(inputFilename.lastIndexOf(slash2) + 1);
					}
					
					System.out.println("inputMTZName: (" + inputMTZName + ")");
					System.out.println("mtzFileName: (" + mtzFileName + ")");
					if (inputMTZName.equals(mtzFileName)) {
						inputObjectIds.add(ent.getKey());
					}
				}
			}
		}
		System.out.println("========== End Search for input files names in repository ===========");

		return inputObjectIds;
	}
}